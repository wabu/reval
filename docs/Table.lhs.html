<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
              "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <title>lhstml</title><meta content="text/html; charset=UTF-8"  http-equiv="Content-Type" />
  </head>
  <body>

<h1>rel-eval is a leazy relational algebra interpreter written in haskell.</h1>
</br>
<pre>Copyright (C) 2007  Daniel Waeber, Fabian Bieker

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
</pre>
</br>
<h1>The Table ADT</h1>
</br>
<pre>> module Table (
>   Row,
>   ColumnName,
>   ColumnHeader,
>   TableHeader,
>   Table(..),
>   testTable,
> )
> where
> 
> import Primes
> import Lib.AssertFun
</pre>
</br>
<h3>The Table</h3>
</br>
As soon as we have Litrals, that can be put into list, it is easy to create
Rows and Tables, as we just can use a Set of Lists of Literals. We only have to
check the types when createing or changeing a Table at runtime.
</br>
Some types to access things more easy:
</br>
<pre>> type Row l = [l]
> type ColumnName = String
> type ColumnHeader t = (ColumnName, t)
> type TableHeader t = [ColumnHeader t]
</pre>
Now we can use these type to create a Table typeclass:
The class consists of a table tab, and the type system l t, which
if functional dependent on tab, as l and t are saved inside tab.
</br>
See SetTable for an implementation.
</br>
Beside constructors and getters, the class has some list processing high order
functions like fold. Therefore, we were able to implement a default implementation for
all other function. That will make it easy to create new implementation for Tables, 
like a real lacy table to process infinite data (e.g. a table with all Fibonacci numbers).
</br>
Note: To Implement this class you need to implement either rows or
	foldRows, mkTableUnsafe and the basic getters. Basic getters
	are header, schema and columnNames.
	We recommend implementing more functions if you care about
	performance.
</br>
<pre>> class (Type t, Literal l t, Eq tab) => Table tab l t | tab -> l t where
</pre>
<h4>Constructors and schema checking:</h4>
</br>
<pre>>       checkTable :: tab -> Bool
>       checkTable t = allRows validRow t && checkSize
>		where
>		sch = schema t
>		validRow r = all (uncurry checkType) (zip sch r)
>		checkSize = allRows (\r -> length sch == length r) t
</pre>
check the Table and return it, if it is valid, otherwise genrate in error
</br>
<pre>>       checkedTable :: tab -> tab
>       checkedTable t
>		| checkTable t = t
>               | otherwise = error ("chechedTable: " ++ 
>			"Invalid unshowable table (you loose).")
>
>       mkTableUnsafe :: (TableHeader t) -> [(Row l)] -> tab
>
>       mkTable :: (TableHeader t) -> [(Row l)] -> tab
>       mkTable h r = checkedTable (mkTableUnsafe h r)
</pre>
<h4>Getters:</h4>
</br>
<pre>>       header :: tab -> TableHeader t
>       schema :: tab -> [t]
>       columnNames :: tab -> [String]
>       rows :: tab -> [Row l]
>	rows = foldRows (:) []
</pre>
Retrun a value out of a row, which is inside table inside a named column.
This function is gets usefull inside projections and theta joins, 
but is not very efficiont.
</br>
<pre>>       getValueUnsave :: tab -> String -> Row l -> l
>       getValue :: tab -> String -> Row l -> l
>
>       getValueUnsave table name row = head [l | (l,n) <- zip row (columnNames table), n == name]
>       getValue table name row = checkedLit $ getValueUnsave table name row
>               where checkedLit lit = if 1 == length [n | n <- columnNames table, n == name]
>                       then lit
>                       else error ("collumn "++name++" not inside the table")
</pre>
<h4>basic functional programming higher order functions:</h4>
Note: default impl. of foldRow is really slow, should be overwriten.
</br>
<pre>>       foldRows :: ((Row l) -> b -> b) -> b -> tab -> b
>	foldRows f init = foldr f init . rows 
>       filterRows :: ((Row l) -> Bool) -> tab -> tab
>	filterRows f t = foldRows
>	 	(\row table -> if f row then cons row table else table) 
>		(mkTable (header t) [])
>		t
</pre>
<h4>mapRowsUnsafe might invalidate the table.</h4>
Use mapRows if you want the table to be validated against the schema.
Use mapRows unsafe if you want the table to be unchecked.
</br>
<pre>>       mapRowsUnsafe :: ((Row l) -> (Row l)) -> tab -> tab
>	mapRowsUnsafe f t = foldRows
>	 	(\row table -> cons (f row) table) 
>		(mkTable (header t) [])
>		t
>	mapRows :: ((Row l) -> (Row l)) -> tab -> tab
>	mapRows f t = checkedTable (mapRowsUnsafe f t)
</pre>
<h4>Basic list-like operations:</h4>
</br>
<pre>>	cons :: (Row l) -> tab -> tab
>	cons r t = mkTable (header t) (r : rows t) 
>	isEmpty :: tab -> Bool
>	isEmpty = null . rows
</pre>
Size returns (count of columns, count of rows)
</br>
<pre>>	size :: tab -> (Int,Int)
>	size t = (length (schema t), length (rows t))
</pre>
<h4>Basic logic operations:</h4>
</br>
<pre>>       allRows :: ((Row l) -> Bool) -> tab -> Bool
>       allRows f = foldRows ((&&) . f) True
>       anyRow :: ((Row l) -> Bool) -> tab -> Bool
>       anyRow f = foldRows ((||) . f) False
</pre>
</br>
<h2>Unit Test</h2>
</br>
TODO: unit test default impls of class Table
</br>
<pre>> testTable = True</pre>
  </body>
</html>
