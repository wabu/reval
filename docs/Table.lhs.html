<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
              "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <title>lhstml</title><meta content="text/html; charset=UTF-8"  http-equiv="Content-Type" />
  </head>
  <body>

<h1>rel-eval is a leazy relational algebra interpreter written in haskell.</h1>

<pre>
Copyright (C) 2007  Daniel Waeber, Fabian Bieker

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
</pre>


<h1>The Table Type</h1>

Or how to trick Haskell to get a Table with different data types inside each
column, but with arbitrary length.

<pre>
> module Table where
> 
> import Lib.AssertFun
> import qualified Data.Set as Set
</pre>




<h2>Our First Try</h2>

... in tricking the type system. The type class look good, but still
we got a problem: There is no way to instantiate it.

<pre>
> {- the class looks good, but can be instanciated
>
> class (Show a) => Row a where
>       name :: a -> String
>       content :: (Show b, Ord b) => a -> [b]
>
> --type Table = (Row a) => [a]
>
> newtype StringRow = SRow (String, [String])
>       deriving (Show, Eq, Read)
>
> instance Row StringRow where
>       name (SRow (n,_))  = n
>       name _ = error "StringRow.name"
>       content (SRow (_,c)) = c
>       content _ = error "StringRow.content"
> -}
</pre>



<h2>The Second Try</h2>

The idea was to create a TableType as a LISP-like cons-cell to represent Tables.
Trying to ignore the type of the second argument, so we can put a TableType d e
did not work, as the type system cam back as we tried to write a on TableType. The
compile will construct the type for the function, but that's an infinite type, so
BOOOMM!! as soon as we use the type.

<pre>
> {- cant be used either
>
> data TableType a b = Nil | Tab (Row a) b
>        deriving (Show, Eq, Read)
>
>
> names Nil = [] 
> names (Tab (name, _ ) b) = names b -- INFINITE TYPE! BOOM!!
> names _ = error "StringRow.name"
> -}
</pre>



<h2>Better: Use ASTs</h2>

Well, screw it, just use ASTs:
<ul>
<li>just a Test List
</li>
<li>you can say something here
 and spread it of more linse
</li>
<li>cool ha?
</li>
<li>you just
 * can't have
 * a sublist
</li>
<li>but you can continue
</li></ul>
Your normal Text


<h3>Basic AST Types</h3>
Lit is a Literal.
TODO: impl. own Show and Read ...

<pre>
> data Lit = Null | IntLit Int | StrLit String | CharLit Char |
>       BoolLit Bool
>       deriving (Show, Eq, Read)
</pre>

Type is used to store Type information in the table schema.
Note: Null has Type Any.

<pre>
> data Type = Any | Number | String | Char | Bool
>       deriving (Show, Eq, Read)
</pre>

Now we can just use Lists as rows, as all data just has the type Lit.

Ord for Lit needed to stuff Lits in Sets

<pre>
> instance Ord Lit where
>       compare Null Null = EQ
>       compare (IntLit a) (IntLit b) = compare a b 
>       compare (StrLit a) (StrLit b) = compare a b 
>       compare (CharLit a) (CharLit b) = compare a b 
>       compare (BoolLit a) (BoolLit b) = compare a b 
>       -- just to keep it consitent
>       compare Null _ = LT
>       compare _ Null = GT
>       compare (IntLit _) _ = LT
>       compare _ (IntLit _) = GT
>       compare (StrLit _) _ = LT
>       compare _ (StrLit _) = GT
>       compare (CharLit _) _ = LT
>       compare _ (CharLit _) = GT
</pre>

check it two types are compatilbe

<pre>
> checkType :: Type -> Type -> Bool
> checkType Any _ = True
> checkType _ Any = True
> checkType Number Number = True
> checkType String String = True
> checkType Char Char = True
> checkType Bool Bool = True
> checkType _ _ = False
</pre>

get type information

<pre>
> getLitType :: Lit -> Type
> getLitType Null = Any
> getLitType (IntLit _) = Number
> getLitType (StrLit _) = String
> getLitType (CharLit _) = Char
> getLitType (BoolLit _) = Bool
</pre>

check for right type

<pre>
> checkLitType :: Type -> Lit -> Bool
> checkLitType t l = checkType t $ getLitType l
</pre>

compare the Type of two Lits

<pre>
> cmpLitType :: Lit -> Lit -> Bool
> cmpLitType Null Null = True
> cmpLitType (IntLit _) (IntLit _) = True
> cmpLitType (StrLit _) (StrLit _) = True
> cmpLitType (CharLit _) (CharLit _) = True
> cmpLitType (BoolLit _) (BoolLit _) = True
> cmpLitType _ _ = False
</pre>


<h3>The Table</h3>
Now Rows and Tables are easy, as we just can use a Set of List. We only have to
check the types when createing or changeing a Table at runtime.

<pre>
> type Row = [Lit]
</pre>

<pre>
> type ColumName = String
> type ColumNames = [ColumName]
</pre>

<pre>
> data Table = Tab (ColumNames, Set.Set Row) 
>       deriving (Show, Eq) -- , Read)
>       -- FIXME:
>       -- =>  No instance for (Read (Data.Set.Set Row))
>       --       arising from the 'deriving' clause of a data type declaration at Table.lhs:127:6
>       --     Probable fix: add an instance declaration for (Read (Data.Set.Set Row))
>       --     When deriving the `Read' instance for type `Table'
</pre>


TODO: impl. own Show and Read ...

<pre>
> mkTable :: ColumNames -> [Row] -> Table
> mkTable names rows =
>        if all (== (length names)) (map length rows) then
>              Tab (names, Set.fromList rows)
>       else
>              error ("length name (" ++ show (length names)
>                     ++ ") /= length rows")
</pre>

Note: mkTable [] [[]] is considered invalid

<pre>
> checkTable :: Table -> Bool
> checkTable (Tab ([], rows)) = Set.null rows
> checkTable (Tab (names, rows)) =
>       Set.null (Set.filter checkLength rows)
>       	&& checkTypes rows	
>       where
>       checkLength row = length row /= length names
>       rowsSize = Set.size rows
>       first = head (Set.toList rows) 
</pre>

check the type of all rows

<pre>
>       checkTypes :: Set.Set Row -> Bool
>       checkTypes rows = rowsSize == 0
>       	||  all checkTyp (Set.toList rows)
</pre>

check the type of one row

<pre>
>       checkTyp :: Row -> Bool
>       checkTyp row = foldr (==) True (map
>       		(\(f,x) -> f x)
>       		(zip (map cmpLitType first) row))
>       	  	
</pre>

perhaps something like this is cooler for typecheking ;)

<pre>
> {-
> all (all (== True)) $ 
>     map                                   -- for each raw
>         ((map (uncurry (==))) .           -- check the types of the pair list
>               ((zip ['a','b','c']) .      -- pairs are zipped out of the table type
>                     map head))            -- and getType map of the row
>         [["a","b","c"],["a","a","c"]] 
> 
>         -- ['a','b','c']->types, head->getType, [[],[]]->table
> -}
</pre>



<h2>UnitTesting:</h2>

<h3>Type System</h3>

<pre>
> int = IntLit 32
> str = StrLit "wabu"
> chr = CharLit '_'
> bool = BoolLit True
> null = Null
> types = [Number, String, Char, Bool]
> lits  = [int, str, chr, bool]
</pre>

<pre>
> testCheckTypeEq = assertfun2 checkType "checkType"
>       ( [(a,a,True) | a <- types] ++
>         [(a,Any,True) | a <- types] ++
>         [(a,Bool,False) | a <- [String,Number,Char]] ++
>         [(a,b,checkType b a) | a <- types, b <- types] ++
>         [(Any,Any,True)] )
</pre>

<pre>
> testCheckLitType = assertfun2 checkLitType "checkLitType"
>       ( [(t,l,True) | (t,l) <- zip types lits] ++
>         [(t,l,False) | i <- [1..4], l <- drop i lits, t <- take i types] ++
>         [(t,l,False) | i <- [1..4], l <- take i lits, t <- drop i types] ++
>         [(Any,l,True) | l <- lits] )
</pre>

<pre>
> testCheckCmpType = assertfun2 cmpLitType "cmpLitType"
>       ( [(a,b,True) | (a,b) <- zip lits lits] ++
>         [(a,b,False) | i <- [1..4], a <- drop i lits, b <- take i lits] ++
>         [(a,b,False) | i <- [1..4], a <- take i lits, b <- drop i lits] ++
>         [(a,b,cmpLitType b a) | a <- lits, b <- lits] ++
>         [(Null,l,False) | l <- lits] ++ [(Null,Null,True)] )
</pre>

<pre>
> testCheckTypes = testCheckTypeEq && testCheckLitType && testCheckCmpType
</pre>


<h3>Table</h3>

<pre>
> tableEmpty = mkTable [] []
</pre>

<pre>
> table1 = mkTable ["ID", "Name"] [
>       [IntLit 23, StrLit "fb"],
>       [IntLit 42, StrLit "daniel"]  ]
</pre>

Yes, those two are valid!

<pre>
> table2 = mkTable ["ID", "Name"] [
>       [IntLit 23, StrLit "fb"],
>       [Null, StrLit "daniel"]  ]
>
> table3 = mkTable ["ID", "Name"] [
>       [Null, StrLit "fb"],
>       [IntLit 42, StrLit "daniel"]  ]
</pre>

<pre>
> tableInvalid = mkTable ["ID", "Name"] [
>       [IntLit 23, StrLit "fb"],
>       [CharLit 'a', StrLit "daniel"]  ]
</pre>

<pre>
> testCheckTable = afun1 checkTable "checktab"
>       [tableEmpty, table1, tableInvalid, table2, table3]
>       [True, True, False, True, True]
</pre>

<pre>
> testAll = testCheckTypes && testCheckTable
</pre>


License foo:

<pre>
> licenseNote = "rel-eval \tCopyright (C) 2007 \tDaniel Waeber, Fabian Bieker\n" ++
>       "This program comes with ABSOLUTELY NO WARRANTY; for details " ++
>       "read the LICENSE.txt file.\n" ++
>       "This is free software, and you are welcome to " ++
>       "redistribute it under certain conditions; type LGPL.txt for " ++
>       "details.\n"
</pre>

  </body>
</html>
